diff -rbNu linux-2.4.22/Makefile linux-2.4.22-rtl3.2-pre3/Makefile
--- linux-2.4.22/Makefile	2003-08-25 13:44:44.000000000 +0200
+++ linux-2.4.22-rtl3.2-pre3/Makefile	2003-10-28 13:08:17.000000000 +0100
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 4
 SUBLEVEL = 22
-EXTRAVERSION =
+EXTRAVERSION =-rtl3.2-pre3
 
 KERNELRELEASE=$(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
 
diff -rbNu linux-2.4.22/arch/i386/config.in linux-2.4.22-rtl3.2-pre3/arch/i386/config.in
--- linux-2.4.22/arch/i386/config.in	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22-rtl3.2-pre3/arch/i386/config.in	2003-10-28 13:03:51.000000000 +0100
@@ -2,11 +2,17 @@
 # For a description of the syntax of this configuration file,
 # see Documentation/kbuild/config-language.txt.
 #
-mainmenu_name "Linux Kernel Configuration"
+mainmenu_name "RTLinux/GPL Kernel Configuration"
 
 define_bool CONFIG_X86 y
 define_bool CONFIG_SBUS n
 
+  
+define_bool CONFIG_RTLINUX  y
+if [ "$CONFIG_RTLINUX" = "y" ]; then
+  define_bool CONFIG_RTL y
+fi
+  
 define_bool CONFIG_UID16 y
 
 mainmenu_option next_comment
diff -rbNu linux-2.4.22/arch/i386/kernel/Makefile linux-2.4.22-rtl3.2-pre3/arch/i386/kernel/Makefile
--- linux-2.4.22/arch/i386/kernel/Makefile	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22-rtl3.2-pre3/arch/i386/kernel/Makefile	2003-10-28 13:03:51.000000000 +0100
@@ -30,6 +30,7 @@
 endif
 endif
 
+obj-$(CONFIG_RTLINUX)           += rtlinux.o
 obj-$(CONFIG_MCA)		+= mca.o
 obj-$(CONFIG_MTRR)		+= mtrr.o
 obj-$(CONFIG_X86_MSR)		+= msr.o
diff -rbNu linux-2.4.22/arch/i386/kernel/apic.c linux-2.4.22-rtl3.2-pre3/arch/i386/kernel/apic.c
--- linux-2.4.22/arch/i386/kernel/apic.c	2003-06-13 16:51:29.000000000 +0200
+++ linux-2.4.22-rtl3.2-pre3/arch/i386/kernel/apic.c	2003-10-28 13:03:51.000000000 +0100
@@ -740,9 +740,9 @@
 
 	spin_lock_irqsave(&i8253_lock, flags);
 
-	outb_p(0x00, 0x43);
-	count = inb_p(0x40);
-	count |= inb_p(0x40) << 8;
+	outb(0x00, 0x43);
+	count = inb(0x40);
+	count |= inb(0x40) << 8;
 
 	spin_unlock_irqrestore(&i8253_lock, flags);
 
diff -rbNu linux-2.4.22/arch/i386/kernel/entry.S linux-2.4.22-rtl3.2-pre3/arch/i386/kernel/entry.S
--- linux-2.4.22/arch/i386/kernel/entry.S	2003-06-13 16:51:29.000000000 +0200
+++ linux-2.4.22-rtl3.2-pre3/arch/i386/kernel/entry.S	2003-10-28 13:03:51.000000000 +0100
@@ -184,6 +184,7 @@
 
 
 ENTRY(ret_from_fork)
+	sti
 	pushl %ebx
 	call SYMBOL_NAME(schedule_tail)
 	addl $4, %esp
@@ -197,11 +198,34 @@
  * but we want the default path for a system call return to
  * go as quickly as possible which is why some of this is
  * less clear than it otherwise should be.
+ *
+ * (c) Victor Yodaiken 1999
+ * RTLINUX_IRET emulates the turn on interrupts effect of
+ * iret since, under RTLinux we may have pended interrupts
+ * that will not be automatically enabled on an iret.
  */
+#ifdef CONFIG_RTLINUX
+#define RTLINUX_IRET 	\
+	movl  rtl_emulate_iret,%eax; \
+	testl %eax, %eax; \
+	je  1f;	\
+	call  *%eax;	\
+	1:
+#else
+#define RTLINUX_IRET
+#endif
 
 ENTRY(system_call)
 	pushl %eax			# save orig_eax
 	SAVE_ALL
+#ifdef CONFIG_RTLINUX
+	movl  rtl_syscall_intercept,%ebx
+	testl %ebx, %ebx
+	je  991f
+	call  *%ebx
+	movl ORIG_EAX(%esp), %eax
+991:
+#endif
 	GET_CURRENT(%ebx)
 	testb $0x02,tsk_ptrace(%ebx)	# PT_TRACESYS
 	jne tracesys
@@ -210,17 +234,21 @@
 	call *SYMBOL_NAME(sys_call_table)(,%eax,4)
 	movl %eax,EAX(%esp)		# save the return value
 ENTRY(ret_from_sys_call)
-	cli				# need_resched and signals atomic test
+	call *(SYMBOL_NAME(irq_control)+8) # cli from irq_control structure
 	cmpl $0,need_resched(%ebx)
 	jne reschedule
 	cmpl $0,sigpending(%ebx)
 	jne signal_return
+	call *(SYMBOL_NAME(irq_control)+12) # sti from irq_control structure
+	
 restore_all:
+	RTLINUX_IRET
 	RESTORE_ALL
 
 	ALIGN
 signal_return:
-	sti				# we can get here from an interrupt handler
+	call *(SYMBOL_NAME(irq_control)+12) # sti from irq_control structure
+	RTLINUX_IRET
 	testl $(VM_MASK),EFLAGS(%esp)
 	movl %esp,%eax
 	jne v86_signal_return
@@ -267,6 +295,12 @@
 	call SYMBOL_NAME(schedule)    # test
 	jmp ret_from_sys_call
 
+#define RTL_PUSH_VECTOR(vector,routine) \
+1:	cmpl $routine, %edi; \
+	jne 1f; \
+	pushl $vector; \
+	jmp 7f;
+
 ENTRY(divide_error)
 	pushl $0		# no error code
 	pushl $ SYMBOL_NAME(do_divide_error)
@@ -294,6 +328,39 @@
 	movl $(__KERNEL_DS),%edx
 	movl %edx,%ds
 	movl %edx,%es
+#ifdef CONFIG_RTLINUX
+	movl  rtl_exception_intercept,%eax
+	testl %eax, %eax
+	je  8f
+	RTL_PUSH_VECTOR(0,do_divide_error)
+	RTL_PUSH_VECTOR(1,do_debug)
+	RTL_PUSH_VECTOR(3,do_int3)
+	RTL_PUSH_VECTOR(4,do_overflow)
+	RTL_PUSH_VECTOR(5,do_bounds)
+	RTL_PUSH_VECTOR(6,do_invalid_op)
+	RTL_PUSH_VECTOR(8,do_double_fault)
+	RTL_PUSH_VECTOR(9,do_coprocessor_segment_overrun)
+	RTL_PUSH_VECTOR(10,do_invalid_TSS)
+	RTL_PUSH_VECTOR(11,do_segment_not_present)
+	RTL_PUSH_VECTOR(12,do_stack_segment)
+	RTL_PUSH_VECTOR(13,do_general_protection)
+	RTL_PUSH_VECTOR(14,do_page_fault)
+	RTL_PUSH_VECTOR(15,do_spurious_interrupt_bug)
+	RTL_PUSH_VECTOR(16,do_coprocessor_error)
+	RTL_PUSH_VECTOR(17,do_alignment_check)
+	RTL_PUSH_VECTOR(18,do_machine_check)
+	RTL_PUSH_VECTOR(19,do_simd_coprocessor_error)
+1:	push $-1
+7:	mov %ecx, %ebx			# ebx will not be corrupted by a C routine
+	call  *%eax
+	popl %ecx
+	mov %ebx, %ecx
+	testl %eax, %eax
+	je 8f
+	addl $8,%esp
+	RESTORE_ALL
+8:
+#endif
 	GET_CURRENT(%ebx)
 	call *%edi
 	addl $8,%esp
@@ -312,6 +379,21 @@
 ENTRY(device_not_available)
 	pushl $-1		# mark this as an int
 	SAVE_ALL
+#ifdef CONFIG_RTLINUX
+	movl  rtl_exception_intercept,%eax
+	testl %eax, %eax
+	je  8f
+	movl %esp,%edx
+	pushl $0		# no error code
+	pushl %edx
+	pushl $7		# vector
+	call  *%eax
+	addl $12,%esp
+	testl %eax, %eax
+	je 8f
+	RESTORE_ALL
+8:
+#endif
 	GET_CURRENT(%ebx)
 	movl %cr0,%eax
 	testl $0x4,%eax			# EM (math emulation bit)
diff -rbNu linux-2.4.22/arch/i386/kernel/i386_ksyms.c linux-2.4.22-rtl3.2-pre3/arch/i386/kernel/i386_ksyms.c
--- linux-2.4.22/arch/i386/kernel/i386_ksyms.c	2003-06-13 16:51:29.000000000 +0200
+++ linux-2.4.22-rtl3.2-pre3/arch/i386/kernel/i386_ksyms.c	2003-10-28 13:03:51.000000000 +0100
@@ -177,6 +177,51 @@
 extern int is_sony_vaio_laptop;
 EXPORT_SYMBOL(is_sony_vaio_laptop);
 
+#ifdef CONFIG_RTLINUX
+#include <asm/mpspec.h>
+#ifdef CONFIG_X86_IO_APIC
+EXPORT_SYMBOL(smp_found_config);
+#endif
+#include <linux/vt_kern.h>
+EXPORT_SYMBOL(kd_mksound);
+extern void *__start_rtlinux_funcs,*__stop_rtlinux_funcs;
+EXPORT_SYMBOL(__start_rtlinux_funcs);
+EXPORT_SYMBOL(__stop_rtlinux_funcs);
+EXPORT_SYMBOL(irq_control);
+extern unsigned long (*do_gettimeoffset)(void);
+extern int use_tsc;
+EXPORT_SYMBOL(do_gettimeoffset);
+EXPORT_SYMBOL(use_tsc);
+EXPORT_SYMBOL(tick);
+extern unsigned long wall_jiffies;
+extern rwlock_t xtime_lock;
+EXPORT_SYMBOL(wall_jiffies);
+EXPORT_SYMBOL(xtime_lock);
+extern unsigned char *rtl_cached21;
+EXPORT_SYMBOL(rtl_cached21);
+extern void (*rtl_do_exit_handler)(long code);
+extern void (*rtl_syscall_intercept)(struct pt_regs regs);
+EXPORT_SYMBOL(init_tss);
+EXPORT_SYMBOL(rtl_syscall_intercept);
+EXPORT_SYMBOL(rtl_do_exit_handler);
+#ifdef CONFIG_SMP
+EXPORT_SYMBOL(flush_tlb_all);
+extern int rtl_reserved_cpumask;
+EXPORT_SYMBOL(rtl_reserved_cpumask);
+extern unsigned long irq_affinity[NR_IRQS];
+EXPORT_SYMBOL(irq_affinity);
+extern volatile int physical_apicid_2_cpu[];
+EXPORT_SYMBOL(physical_apicid_2_cpu);
+extern unsigned long flush_cpumask;
+EXPORT_SYMBOL(flush_cpumask);
+EXPORT_SYMBOL(cpu_tlbstate);
+#endif /* CONFIG_SMP */
+extern struct console *console_drivers;
+EXPORT_SYMBOL(console_drivers);
+EXPORT_SYMBOL(set_ldt_desc);
+EXPORT_SYMBOL(default_ldt);
+#endif /* CONFIG_RTLINUX */
+
 #ifdef CONFIG_MULTIQUAD
 EXPORT_SYMBOL(xquad_portio);
 #endif
diff -rbNu linux-2.4.22/arch/i386/kernel/i8259.c linux-2.4.22-rtl3.2-pre3/arch/i386/kernel/i8259.c
--- linux-2.4.22/arch/i386/kernel/i8259.c	2001-09-18 08:03:09.000000000 +0200
+++ linux-2.4.22-rtl3.2-pre3/arch/i386/kernel/i8259.c	2003-10-28 13:03:51.000000000 +0100
@@ -131,6 +131,14 @@
 
 spinlock_t i8259A_lock = SPIN_LOCK_UNLOCKED;
 
+#ifdef CONFIG_RTLINUX
+#undef spin_lock_irqsave
+#define spin_lock_irqsave(lock, flags)		do { rtl_hard_local_irq_save_kernel(flags);       spin_lock(lock); } while (0)
+
+#undef spin_unlock_irqrestore
+#define spin_unlock_irqrestore(lock, flags)	do { spin_unlock(lock);  rtl_hard_local_irq_restore_kernel(flags); } while (0)
+#endif
+
 static void end_8259A_irq (unsigned int irq)
 {
 	if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS)))
@@ -171,6 +179,8 @@
 #define cached_21	(__byte(0,cached_irq_mask))
 #define cached_A1	(__byte(1,cached_irq_mask))
 
+unsigned char *rtl_cached21=&cached_21;
+
 /*
  * Not all IRQs can be routed through the IO-APIC, eg. on certain (older)
  * boards the timer interrupt is not really connected to any IO-APIC pin,
@@ -343,20 +353,20 @@
 	outb(0xff, 0xA1);	/* mask all of 8259A-2 */
 
 	/*
-	 * outb_p - this has to work on a wide range of PC hardware.
+	 * outb - this has to work on a wide range of PC hardware.
 	 */
-	outb_p(0x11, 0x20);	/* ICW1: select 8259A-1 init */
-	outb_p(0x20 + 0, 0x21);	/* ICW2: 8259A-1 IR0-7 mapped to 0x20-0x27 */
-	outb_p(0x04, 0x21);	/* 8259A-1 (the master) has a slave on IR2 */
+	outb(0x11, 0x20);	/* ICW1: select 8259A-1 init */
+	outb(0x20 + 0, 0x21);	/* ICW2: 8259A-1 IR0-7 mapped to 0x20-0x27 */
+	outb(0x04, 0x21);	/* 8259A-1 (the master) has a slave on IR2 */
 	if (auto_eoi)
-		outb_p(0x03, 0x21);	/* master does Auto EOI */
+		outb(0x03, 0x21);	/* master does Auto EOI */
 	else
-		outb_p(0x01, 0x21);	/* master expects normal EOI */
+		outb(0x01, 0x21);	/* master expects normal EOI */
 
-	outb_p(0x11, 0xA0);	/* ICW1: select 8259A-2 init */
-	outb_p(0x20 + 8, 0xA1);	/* ICW2: 8259A-2 IR0-7 mapped to 0x28-0x2f */
-	outb_p(0x02, 0xA1);	/* 8259A-2 is a slave on master's IR2 */
-	outb_p(0x01, 0xA1);	/* (slave's support for AEOI in flat mode
+	outb(0x11, 0xA0);	/* ICW1: select 8259A-2 init */
+	outb(0x20 + 8, 0xA1);	/* ICW2: 8259A-2 IR0-7 mapped to 0x28-0x2f */
+	outb(0x02, 0xA1);	/* 8259A-2 is a slave on master's IR2 */
+	outb(0x01, 0xA1);	/* (slave's support for AEOI in flat mode
 				    is to be investigated) */
 
 	if (auto_eoi)
@@ -493,8 +503,8 @@
 	 * Set the clock to HZ Hz, we already have a valid
 	 * vector now:
 	 */
-	outb_p(0x34,0x43);		/* binary, mode 2, LSB/MSB, ch 0 */
-	outb_p(LATCH & 0xff , 0x40);	/* LSB */
+	outb(0x34,0x43);		/* binary, mode 2, LSB/MSB, ch 0 */
+	outb(LATCH & 0xff , 0x40);	/* LSB */
 	outb(LATCH >> 8 , 0x40);	/* MSB */
 
 #ifndef CONFIG_VISWS
diff -rbNu linux-2.4.22/arch/i386/kernel/io_apic.c linux-2.4.22-rtl3.2-pre3/arch/i386/kernel/io_apic.c
--- linux-2.4.22/arch/i386/kernel/io_apic.c	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22-rtl3.2-pre3/arch/i386/kernel/io_apic.c	2003-10-28 13:03:51.000000000 +0100
@@ -46,6 +46,14 @@
 unsigned char int_delivery_mode = dest_LowestPrio;
 
 
+#ifdef CONFIG_RTLINUX
+#undef spin_lock_irqsave
+#define spin_lock_irqsave(lock, flags)		do { rtl_hard_local_irq_save_kernel(flags);       spin_lock(lock); } while (0)
+
+#undef spin_unlock_irqrestore
+#define spin_unlock_irqrestore(lock, flags)	do { spin_unlock(lock);  rtl_hard_local_irq_restore_kernel(flags); } while (0)
+#endif
+
 /*
  * # of IRQ routing registers
  */
diff -rbNu linux-2.4.22/arch/i386/kernel/irq.c linux-2.4.22-rtl3.2-pre3/arch/i386/kernel/irq.c
--- linux-2.4.22/arch/i386/kernel/irq.c	2002-11-29 00:53:09.000000000 +0100
+++ linux-2.4.22-rtl3.2-pre3/arch/i386/kernel/irq.c	2003-10-28 13:03:51.000000000 +0100
@@ -1090,7 +1090,7 @@
 
 static struct proc_dir_entry * smp_affinity_entry [NR_IRQS];
 
-static unsigned long irq_affinity [NR_IRQS] = { [0 ... NR_IRQS-1] = ~0UL };
+unsigned long irq_affinity [NR_IRQS] = { [0 ... NR_IRQS-1] = ~0UL };
 static int irq_affinity_read_proc (char *page, char **start, off_t off,
 			int count, int *eof, void *data)
 {
diff -rbNu linux-2.4.22/arch/i386/kernel/nmi.c linux-2.4.22-rtl3.2-pre3/arch/i386/kernel/nmi.c
--- linux-2.4.22/arch/i386/kernel/nmi.c	2003-06-13 16:51:29.000000000 +0200
+++ linux-2.4.22-rtl3.2-pre3/arch/i386/kernel/nmi.c	2003-10-28 13:03:51.000000000 +0100
@@ -344,7 +344,12 @@
 	 * Since current-> is always on the stack, and we always switch
 	 * the stack NMI-atomically, it's safe to use smp_processor_id().
 	 */
+#ifdef CONFIG_RTLINUX
+	/* For RTLinux this is not always the case, hence hard_smp_processor_id */
+	int sum, cpu = hw_smp_processor_id();
+#else
 	int sum, cpu = smp_processor_id();
+#endif
 
 	sum = apic_timer_irqs[cpu];
 
diff -rbNu linux-2.4.22/arch/i386/kernel/pci-irq.c linux-2.4.22-rtl3.2-pre3/arch/i386/kernel/pci-irq.c
--- linux-2.4.22/arch/i386/kernel/pci-irq.c	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22-rtl3.2-pre3/arch/i386/kernel/pci-irq.c	2003-10-28 13:03:51.000000000 +0100
@@ -402,14 +402,14 @@
  */
 static int pirq_serverworks_get(struct pci_dev *router, struct pci_dev *dev, int pirq)
 {
-	outb_p(pirq, 0xc00);
+	outb(pirq, 0xc00);
 	return inb(0xc01) & 0xf;
 }
 
 static int pirq_serverworks_set(struct pci_dev *router, struct pci_dev *dev, int pirq, int irq)
 {
-	outb_p(pirq, 0xc00);
-	outb_p(irq, 0xc01);
+	outb(pirq, 0xc00);
+	outb(irq, 0xc01);
 	return 1;
 }
 
diff -rbNu linux-2.4.22/arch/i386/kernel/process.c linux-2.4.22-rtl3.2-pre3/arch/i386/kernel/process.c
--- linux-2.4.22/arch/i386/kernel/process.c	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22-rtl3.2-pre3/arch/i386/kernel/process.c	2003-10-28 13:03:51.000000000 +0100
@@ -267,7 +267,7 @@
 	int i;
 
 	for (i=0; i<0x10000; i++)
-		if ((inb_p(0x64) & 0x02) == 0)
+		if ((inb(0x64) & 0x02) == 0)
 			break;
 }
 
diff -rbNu linux-2.4.22/arch/i386/kernel/rtlinux.c linux-2.4.22-rtl3.2-pre3/arch/i386/kernel/rtlinux.c
--- linux-2.4.22/arch/i386/kernel/rtlinux.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.22-rtl3.2-pre3/arch/i386/kernel/rtlinux.c	2003-10-28 13:03:51.000000000 +0100
@@ -0,0 +1,80 @@
+#include <linux/config.h>
+#include <linux/ptrace.h>
+#include <linux/errno.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/ioport.h>
+#include <linux/interrupt.h>
+#include <linux/timex.h>
+#include <linux/malloc.h>
+#include <linux/random.h>
+#include <linux/smp_lock.h>
+#include <linux/init.h>
+#include <linux/kernel_stat.h>
+
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/bitops.h>
+#include <asm/pgtable.h>
+#include <asm/delay.h>
+#include <asm/desc.h>
+
+#include <linux/irq.h>
+
+static void rtl_hard_save_flags_f(unsigned long  *z){
+	unsigned long y;
+	rtl_hard_save_flags_kernel(y);
+	*z=y;
+}
+static void rtl_hard_restore_flags_f(unsigned long  x) { rtl_hard_restore_flags_kernel(x); }
+static void rtl_hard_cli_f(void) { rtl_hard_cli_kernel(); }
+static void rtl_hard_sti_f(void) { rtl_hard_sti_kernel(); }
+static void rtl_hard_local_irq_save_f(unsigned long  *x)
+{ unsigned long y;rtl_hard_local_irq_save_kernel(y);*x=y; }
+static void rtl_hard_local_irq_restore_f(unsigned long  x){
+	rtl_hard_local_irq_restore_kernel(x);
+}
+struct irq_control_s irq_control = {
+ 	rtl_hard_save_flags_f,
+ 	rtl_hard_restore_flags_f,
+ 	rtl_hard_cli_f,
+ 	rtl_hard_sti_f,
+ 	rtl_hard_local_irq_save_f,
+ 	rtl_hard_local_irq_restore_f
+ };
+void *rtl_emulate_iret = 0;
+void *rtl_exception_intercept = 0;
+void *rtl_syscall_intercept = 0;
+
+extern void *__start_rtlinux_patch,*__stop_rtlinux_patch;
+extern asmlinkage void do_IRQ(struct pt_regs );
+extern void ret_from_intr(void);
+RTLINUX_EXPORT(__start_rtlinux_patch);
+RTLINUX_EXPORT(__stop_rtlinux_patch);
+RTLINUX_EXPORT(rtl_emulate_iret);
+RTLINUX_EXPORT(irq_desc);
+RTLINUX_EXPORT(do_IRQ);
+RTLINUX_EXPORT(ret_from_intr);
+RTLINUX_EXPORT(rtl_exception_intercept);
+
+#ifdef CONFIG_X86_LOCAL_APIC
+extern asmlinkage void smp_spurious_interrupt(void);
+extern asmlinkage void smp_error_interrupt(void);
+extern void smp_apic_timer_interrupt(struct pt_regs *);
+
+RTLINUX_EXPORT(smp_spurious_interrupt);
+RTLINUX_EXPORT(smp_error_interrupt);
+RTLINUX_EXPORT(smp_apic_timer_interrupt);
+#endif
+
+#ifdef CONFIG_SMP
+extern void rtl_reschedule(int cpu);
+extern asmlinkage void smp_reschedule_interrupt(void);
+extern asmlinkage void smp_invalidate_interrupt(void);
+extern asmlinkage void smp_call_function_interrupt(void);
+RTLINUX_EXPORT(smp_reschedule_interrupt);
+RTLINUX_EXPORT(smp_invalidate_interrupt);
+RTLINUX_EXPORT(smp_call_function_interrupt);
+RTLINUX_EXPORT(rtl_reschedule);
+#endif
diff -rbNu linux-2.4.22/arch/i386/kernel/setup.c linux-2.4.22-rtl3.2-pre3/arch/i386/kernel/setup.c
--- linux-2.4.22/arch/i386/kernel/setup.c	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22-rtl3.2-pre3/arch/i386/kernel/setup.c	2003-10-28 13:03:51.000000000 +0100
@@ -268,7 +268,7 @@
 {
 	int raw;
 
-	visws_board_type = (char)(inb_p(PIIX_GPI_BD_REG) & PIIX_GPI_BD_REG)
+	visws_board_type = (char)(inb(PIIX_GPI_BD_REG) & PIIX_GPI_BD_REG)
 							 >> PIIX_GPI_BD_SHIFT;
 /*
  * Get Board rev.
@@ -276,40 +276,40 @@
  * to the GPIO registers.  Let's map them at 0x0fc0 which is right
  * after the PIIX4 PM section.
  */
-	outb_p(SIO_DEV_SEL, SIO_INDEX);
-	outb_p(SIO_GP_DEV, SIO_DATA);	/* Talk to GPIO regs. */
+	outb(SIO_DEV_SEL, SIO_INDEX);
+	outb(SIO_GP_DEV, SIO_DATA);	/* Talk to GPIO regs. */
     
-	outb_p(SIO_DEV_MSB, SIO_INDEX);
-	outb_p(SIO_GP_MSB, SIO_DATA);	/* MSB of GPIO base address */
+	outb(SIO_DEV_MSB, SIO_INDEX);
+	outb(SIO_GP_MSB, SIO_DATA);	/* MSB of GPIO base address */
 
-	outb_p(SIO_DEV_LSB, SIO_INDEX);
-	outb_p(SIO_GP_LSB, SIO_DATA);	/* LSB of GPIO base address */
+	outb(SIO_DEV_LSB, SIO_INDEX);
+	outb(SIO_GP_LSB, SIO_DATA);	/* LSB of GPIO base address */
 
-	outb_p(SIO_DEV_ENB, SIO_INDEX);
-	outb_p(1, SIO_DATA);		/* Enable GPIO registers. */
+	outb(SIO_DEV_ENB, SIO_INDEX);
+	outb(1, SIO_DATA);		/* Enable GPIO registers. */
     
 /*
  * Now, we have to map the power management section to write
  * a bit which enables access to the GPIO registers.
  * What lunatic came up with this shit?
  */
-	outb_p(SIO_DEV_SEL, SIO_INDEX);
-	outb_p(SIO_PM_DEV, SIO_DATA);	/* Talk to GPIO regs. */
+	outb(SIO_DEV_SEL, SIO_INDEX);
+	outb(SIO_PM_DEV, SIO_DATA);	/* Talk to GPIO regs. */
 
-	outb_p(SIO_DEV_MSB, SIO_INDEX);
-	outb_p(SIO_PM_MSB, SIO_DATA);	/* MSB of PM base address */
+	outb(SIO_DEV_MSB, SIO_INDEX);
+	outb(SIO_PM_MSB, SIO_DATA);	/* MSB of PM base address */
     
-	outb_p(SIO_DEV_LSB, SIO_INDEX);
-	outb_p(SIO_PM_LSB, SIO_DATA);	/* LSB of PM base address */
+	outb(SIO_DEV_LSB, SIO_INDEX);
+	outb(SIO_PM_LSB, SIO_DATA);	/* LSB of PM base address */
 
-	outb_p(SIO_DEV_ENB, SIO_INDEX);
-	outb_p(1, SIO_DATA);		/* Enable PM registers. */
+	outb(SIO_DEV_ENB, SIO_INDEX);
+	outb(1, SIO_DATA);		/* Enable PM registers. */
     
 /*
  * Now, write the PM register which enables the GPIO registers.
  */
-	outb_p(SIO_PM_FER2, SIO_PM_INDEX);
-	outb_p(SIO_PM_GP_EN, SIO_PM_DATA);
+	outb(SIO_PM_FER2, SIO_PM_INDEX);
+	outb(SIO_PM_GP_EN, SIO_PM_DATA);
     
 /*
  * Now, initialize the GPIO registers.
@@ -317,7 +317,7 @@
  * power on default, so let's leave them alone.
  * So, let's just read the board rev!
  */
-	raw = inb_p(SIO_GP_DATA1);
+	raw = inb(SIO_GP_DATA1);
 	raw &= 0x7f;	/* 7 bits of valid board revision ID. */
 
 	if (visws_board_type == VISWS_320) {
diff -rbNu linux-2.4.22/arch/i386/kernel/smp.c linux-2.4.22-rtl3.2-pre3/arch/i386/kernel/smp.c
--- linux-2.4.22/arch/i386/kernel/smp.c	2003-06-13 16:51:29.000000000 +0200
+++ linux-2.4.22-rtl3.2-pre3/arch/i386/kernel/smp.c	2003-10-28 13:03:51.000000000 +0100
@@ -134,6 +134,10 @@
 	 */
 	unsigned int cfg;
 
+#ifdef CONFIG_RTLINUX
+	unsigned long flags;
+	rtl_hard_local_irq_save_kernel(flags);
+#endif
 	/*
 	 * Wait for idle.
 	 */
@@ -148,6 +152,9 @@
 	 * Send the IPI. The write to APIC_ICR fires this off.
 	 */
 	apic_write_around(APIC_ICR, cfg);
+#ifdef CONFIG_RTLINUX
+	rtl_hard_local_irq_restore_kernel(flags);
+#endif
 }
 
 void send_IPI_self(int vector)
@@ -160,8 +167,12 @@
 	unsigned long cfg;
 	unsigned long flags;
 
+#ifdef CONFIG_RTLINUX
+	rtl_hard_local_irq_save_kernel(flags);
+#else
 	__save_flags(flags);
 	__cli();
+#endif
 
 		
 	/*
@@ -185,7 +196,11 @@
 	 */
 	apic_write_around(APIC_ICR, cfg);
 
+#ifdef CONFIG_RTLINUX
+	rtl_hard_local_irq_restore_kernel(flags);
+#else
 	__restore_flags(flags);
+#endif
 }
 
 static inline void send_IPI_mask_sequence(int mask, int vector)
@@ -199,8 +214,12 @@
 	 * should be modified to do 1 message per cluster ID - mbligh
 	 */ 
 
+#ifdef CONFIG_RTLINUX
+	rtl_hard_local_irq_save_kernel(flags);
+#else
 	__save_flags(flags);
 	__cli();
+#endif
 
 	for (query_cpu = 0; query_cpu < NR_CPUS; ++query_cpu) {
 		query_mask = 1 << query_cpu;
@@ -231,7 +250,11 @@
 			apic_write_around(APIC_ICR, cfg);
 		}
 	}
+#ifdef CONFIG_RTLINUX
+	rtl_hard_local_irq_restore_kernel(flags);
+#else
 	__restore_flags(flags);
+#endif
 }
 
 static inline void send_IPI_mask(int mask, int vector)
@@ -292,7 +315,7 @@
  *	Optimizations Manfred Spraul <manfred@colorfullife.com>
  */
 
-static volatile unsigned long flush_cpumask;
+volatile unsigned long flush_cpumask;
 static struct mm_struct * flush_mm;
 static unsigned long flush_va;
 static spinlock_t tlbstate_lock = SPIN_LOCK_UNLOCKED;
@@ -386,6 +409,10 @@
 	clear_bit(cpu, &flush_cpumask);
 }
 
+#ifdef CONFIG_RTLINUX
+int rtl_reserved_cpumask;
+#endif
+
 static void flush_tlb_others (unsigned long cpumask, struct mm_struct *mm,
 						unsigned long va)
 {
@@ -416,6 +443,10 @@
 	flush_mm = mm;
 	flush_va = va;
 	atomic_set_mask(cpumask, &flush_cpumask);
+#ifdef CONFIG_RTLINUX
+	/* make shure that reserved cpu's are excluded ! */
+	atomic_clear_mask(rtl_reserved_cpumask,&flush_cpumask);
+#endif
 	/*
 	 * We have to send the IPI only to
 	 * CPUs affected.
@@ -502,6 +533,13 @@
 	send_IPI_mask(1 << cpu, RESCHEDULE_VECTOR);
 }
 
+#ifdef CONFIG_RTLINUX
+#define RTL_RESCHEDULE_VECTOR 0xEE
+void rtl_reschedule(int cpu)
+{
+	send_IPI_mask(1 << cpu, RTL_RESCHEDULE_VECTOR);
+}
+#endif
 /*
  * Structure and data for smp_call_function(). This is designed to minimise
  * static memory requirements. It also looks cleaner.
diff -rbNu linux-2.4.22/arch/i386/kernel/time.c linux-2.4.22-rtl3.2-pre3/arch/i386/kernel/time.c
--- linux-2.4.22/arch/i386/kernel/time.c	2003-06-13 16:51:29.000000000 +0200
+++ linux-2.4.22-rtl3.2-pre3/arch/i386/kernel/time.c	2003-10-28 13:03:51.000000000 +0100
@@ -121,7 +121,7 @@
 
 extern spinlock_t i8259A_lock;
 
-#ifndef CONFIG_X86_TSC
+#if defined (CONFIG_RTLINUX) || ! defined (CONFIG_X86_TSC)
 
 /* This function must be called with interrupts disabled 
  * It was inspired by Steve McCanne's microtime-i386 for BSD.  -- jrs
@@ -170,9 +170,9 @@
 	/* gets recalled with irq locally disabled */
 	spin_lock(&i8253_lock);
 	/* timer count may underflow right here */
-	outb_p(0x00, 0x43);	/* latch the count ASAP */
+	outb(0x00, 0x43);	/* latch the count ASAP */
 
-	count = inb_p(0x40);	/* read the latched count */
+	count = inb(0x40);	/* read the latched count */
 
 	/*
 	 * We do this guaranteed double memory access instead of a _p 
@@ -180,12 +180,12 @@
 	 */
  	jiffies_t = jiffies;
 
-	count |= inb_p(0x40) << 8;
+	count |= inb(0x40) << 8;
 	
         /* VIA686a test code... reset the latch if count > max + 1 */
         if (count > LATCH) {
-                outb_p(0x34, 0x43);
-                outb_p(LATCH & 0xff, 0x40);
+                outb(0x34, 0x43);
+                outb(LATCH & 0xff, 0x40);
                 outb(LATCH >> 8, 0x40);
                 count = LATCH - 1;
         }
@@ -211,6 +211,10 @@
 
 			int i;
 
+#ifdef CONFIG_RTLINUX
+			unsigned long flags;
+			rtl_hard_local_irq_save_kernel(flags);
+#endif
 			spin_lock(&i8259A_lock);
 			/*
 			 * This is tricky when I/O APICs are used;
@@ -218,6 +222,9 @@
 			 */
 			i = inb(0x20);
 			spin_unlock(&i8259A_lock);
+#ifdef CONFIG_RTLINUX
+			rtl_hard_local_irq_restore_kernel(flags);
+#endif
 
 			/* assumption about timer being IRQ0 */
 			if (i & 0x01) {
@@ -254,7 +261,7 @@
 	return count;
 }
 
-static unsigned long (*do_gettimeoffset)(void) = do_slow_gettimeoffset;
+unsigned long (*do_gettimeoffset)(void) = do_slow_gettimeoffset;
 
 
 /* IBM Summit (EXA) Cyclone Timer code*/
@@ -576,11 +583,18 @@
 		 * This will also deassert NMI lines for the watchdog if run
 		 * on an 82489DX-based system.
 		 */
+#ifdef CONFIG_RTLINUX
+		unsigned long flags;
+		rtl_hard_local_irq_save_kernel(flags);
+#endif
 		spin_lock(&i8259A_lock);
 		outb(0x0c, 0x20);
 		/* Ack the IRQ; AEOI will end it automatically. */
 		inb(0x20);
 		spin_unlock(&i8259A_lock);
+#ifdef CONFIG_RTLINUX
+		rtl_hard_local_irq_restore_kernel(flags);
+#endif
 	}
 #endif
 
@@ -628,13 +642,13 @@
 		high bit of the PPI port B (0x61).  Note that some PS/2s,
 		notably the 55SX, work fine if this is removed.  */
 
-		irq = inb_p( 0x61 );	/* read the current state */
-		outb_p( irq|0x80, 0x61 );	/* reset the IRQ */
+		irq = inb( 0x61 );	/* read the current state */
+		outb( irq|0x80, 0x61 );	/* reset the IRQ */
 	}
 #endif
 }
 
-static int use_tsc;
+int use_tsc;
 
 /*
  * This is the same as the above, except we _also_ save the current
@@ -674,9 +688,9 @@
 		rdtscl(last_tsc_low);
 
 		spin_lock(&i8253_lock);
-		outb_p(0x00, 0x43);     /* latch the count ASAP */
+		outb(0x00, 0x43);     /* latch the count ASAP */
 
-		count = inb_p(0x40);    /* read the latched count */
+		count = inb(0x40);    /* read the latched count */
 		count |= inb(0x40) << 8;
 
 		/* Any unpaired read will cause the above to swap MSB/LSB
diff -rbNu linux-2.4.22/arch/i386/kernel/traps.c linux-2.4.22-rtl3.2-pre3/arch/i386/kernel/traps.c
--- linux-2.4.22/arch/i386/kernel/traps.c	2002-11-29 00:53:09.000000000 +0100
+++ linux-2.4.22-rtl3.2-pre3/arch/i386/kernel/traps.c	2003-10-28 13:03:51.000000000 +0100
@@ -467,11 +467,16 @@
 	printk("Do you have a strange power saving mode enabled?\n");
 }
 
+
 asmlinkage void do_nmi(struct pt_regs * regs, long error_code)
 {
 	unsigned char reason = inb(0x61);
 
+#ifdef CONFIG_RTLINUX
+	++nmi_count(hw_smp_processor_id());
+#else
 	++nmi_count(smp_processor_id());
+#endif
 
 	if (!(reason & 0xc0)) {
 #if CONFIG_X86_LOCAL_APIC
diff -rbNu linux-2.4.22/arch/i386/mm/fault.c linux-2.4.22-rtl3.2-pre3/arch/i386/mm/fault.c
--- linux-2.4.22/arch/i386/mm/fault.c	2002-11-29 00:53:09.000000000 +0100
+++ linux-2.4.22-rtl3.2-pre3/arch/i386/mm/fault.c	2003-10-28 13:03:51.000000000 +0100
@@ -25,6 +25,9 @@
 #include <asm/pgalloc.h>
 #include <asm/hardirq.h>
 
+// need that for hard_sti in do_page_fault - thanks to Paolo Mantegazza .
+#include <asm/rtlinux_cli.h>
+
 extern void die(const char *,struct pt_regs *,long);
 
 /*
@@ -153,8 +156,8 @@
 
 	/* It's safe to allow irq's after cr2 has been saved */
 	if (regs->eflags & X86_EFLAGS_IF)
-		local_irq_enable();
-
+//		local_irq_enable();
+ 		rtl_hard_sti_kernel();
 	tsk = current;
 
 	/*
diff -rbNu linux-2.4.22/arch/i386/mm/ioremap.c linux-2.4.22-rtl3.2-pre3/arch/i386/mm/ioremap.c
--- linux-2.4.22/arch/i386/mm/ioremap.c	2002-08-03 02:39:42.000000000 +0200
+++ linux-2.4.22-rtl3.2-pre3/arch/i386/mm/ioremap.c	2003-10-28 13:03:51.000000000 +0100
@@ -82,6 +82,7 @@
 					 phys_addr + address, flags))
 			break;
 		error = 0;
+		set_pgdir(address, *dir);
 		address = (address + PGDIR_SIZE) & PGDIR_MASK;
 		dir++;
 	} while (address && (address < end));
diff -rbNu linux-2.4.22/include/asm-i386/apic.h linux-2.4.22-rtl3.2-pre3/include/asm-i386/apic.h
--- linux-2.4.22/include/asm-i386/apic.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.22-rtl3.2-pre3/include/asm-i386/apic.h	2003-10-28 13:09:21.000000000 +0100
@@ -52,6 +52,9 @@
 
 static inline void ack_APIC_irq(void)
 {
+#ifdef CONFIG_RTLINUX
+ 	label_ack_APIC(); /* used to generate RTLinux patch point */
+#endif
 	/*
 	 * ack_APIC_irq() actually gets compiled as a single instruction:
 	 * - a single rmw on Pentium/82489DX
diff -rbNu linux-2.4.22/include/asm-i386/floppy.h linux-2.4.22-rtl3.2-pre3/include/asm-i386/floppy.h
--- linux-2.4.22/include/asm-i386/floppy.h	2003-06-13 16:51:38.000000000 +0200
+++ linux-2.4.22-rtl3.2-pre3/include/asm-i386/floppy.h	2003-10-28 13:15:12.000000000 +0100
@@ -30,9 +30,11 @@
 #define SW fd_routine[use_virtual_dma&1]
 #define CSW fd_routine[can_use_virtual_dma & 1]
 
-
-#define fd_inb(port)			inb_p(port)
-#define fd_outb(port,value)		outb_p(port,value)
+/* lets see if floppies can live with outb/inb....hofrat */
+//#define fd_inb(port)			inb_p(port)
+//#define fd_outb(port,value)		outb_p(port,value)
+#define fd_inb(port)			inb(port)
+#define fd_outb(port,value)		outb(port,value)
 
 #define fd_request_dma()        CSW._request_dma(FLOPPY_DMA,"floppy")
 #define fd_free_dma()           CSW._free_dma(FLOPPY_DMA)
diff -rbNu linux-2.4.22/include/asm-i386/hw_irq.h linux-2.4.22-rtl3.2-pre3/include/asm-i386/hw_irq.h
--- linux-2.4.22/include/asm-i386/hw_irq.h	2003-08-25 13:44:43.000000000 +0200
+++ linux-2.4.22-rtl3.2-pre3/include/asm-i386/hw_irq.h	2003-10-28 13:09:21.000000000 +0100
@@ -15,6 +15,7 @@
 #include <linux/config.h>
 #include <asm/atomic.h>
 #include <asm/irq.h>
+#include <asm/rtlinux.h>
 
 /*
  * IDT vectors usable for external interrupt sources start
@@ -126,41 +127,39 @@
 #define BUILD_SMP_INTERRUPT(x,v) XBUILD_SMP_INTERRUPT(x,v)
 #define XBUILD_SMP_INTERRUPT(x,v)\
 asmlinkage void x(void); \
-asmlinkage void call_##x(void); \
 __asm__( \
 "\n"__ALIGN_STR"\n" \
 SYMBOL_NAME_STR(x) ":\n\t" \
-	"pushl $"#v"-256\n\t" \
+	"pushl $"#v"\n\t" \
 	SAVE_ALL \
-	SYMBOL_NAME_STR(call_##x)":\n\t" \
-	"call "SYMBOL_NAME_STR(smp_##x)"\n\t" \
+	"pushl $ret_from_intr\n\t" \
+        RTLINUX_LABEL(smp_##x)\
+        "jmp "SYMBOL_NAME_STR(smp_##x)"\n\t" \
 	"jmp ret_from_intr\n");
 
 #define BUILD_SMP_TIMER_INTERRUPT(x,v) XBUILD_SMP_TIMER_INTERRUPT(x,v)
 #define XBUILD_SMP_TIMER_INTERRUPT(x,v) \
 asmlinkage void x(struct pt_regs * regs); \
-asmlinkage void call_##x(void); \
 __asm__( \
 "\n"__ALIGN_STR"\n" \
 SYMBOL_NAME_STR(x) ":\n\t" \
-	"pushl $"#v"-256\n\t" \
+	"pushl $"#v"\n\t" \
 	SAVE_ALL \
 	"movl %esp,%eax\n\t" \
 	"pushl %eax\n\t" \
-	SYMBOL_NAME_STR(call_##x)":\n\t" \
+        RTLINUX_LABEL(smp_##x)\
 	"call "SYMBOL_NAME_STR(smp_##x)"\n\t" \
 	"addl $4,%esp\n\t" \
 	"jmp ret_from_intr\n");
 
 #define BUILD_COMMON_IRQ() \
-asmlinkage void call_do_IRQ(void); \
 __asm__( \
 	"\n" __ALIGN_STR"\n" \
 	"common_interrupt:\n\t" \
 	SAVE_ALL \
-	SYMBOL_NAME_STR(call_do_IRQ)":\n\t" \
-	"call " SYMBOL_NAME_STR(do_IRQ) "\n\t" \
-	"jmp ret_from_intr\n");
+ 	"pushl $ret_from_intr\n\t" \
+        RTLINUX_LABEL(do_IRQ)"\n\t" \
+	"jmp "SYMBOL_NAME_STR(do_IRQ));
 
 /* 
  * subtle. orig_eax is used by the signal code to distinct between
diff -rbNu linux-2.4.22/include/asm-i386/irq.h linux-2.4.22-rtl3.2-pre3/include/asm-i386/irq.h
--- linux-2.4.22/include/asm-i386/irq.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.22-rtl3.2-pre3/include/asm-i386/irq.h	2003-10-28 13:09:21.000000000 +0100
@@ -23,7 +23,7 @@
  * Since vectors 0x00-0x1f are used/reserved for the CPU,
  * the usable vector space is 0x20-0xff (224 vectors)
  */
-#ifdef CONFIG_X86_IO_APIC
+#if defined( CONFIG_X86_IO_APIC ) || defined ( CONFIG_RTLINUX )
 #define NR_IRQS 224
 #else
 #define NR_IRQS 16
@@ -37,6 +37,7 @@
 extern void disable_irq(unsigned int);
 extern void disable_irq_nosync(unsigned int);
 extern void enable_irq(unsigned int);
+struct task_struct;
 extern void release_x86_irqs(struct task_struct *);
 
 #ifdef CONFIG_X86_LOCAL_APIC
diff -rbNu linux-2.4.22/include/asm-i386/param.h linux-2.4.22-rtl3.2-pre3/include/asm-i386/param.h
--- linux-2.4.22/include/asm-i386/param.h	2000-10-27 20:04:43.000000000 +0200
+++ linux-2.4.22-rtl3.2-pre3/include/asm-i386/param.h	2003-10-28 13:03:54.000000000 +0100
@@ -2,7 +2,7 @@
 #define _ASMi386_PARAM_H
 
 #ifndef HZ
-#define HZ 100
+#define HZ 1000
 #endif
 
 #define EXEC_PAGESIZE	4096
diff -rbNu linux-2.4.22/include/asm-i386/pgalloc.h linux-2.4.22-rtl3.2-pre3/include/asm-i386/pgalloc.h
--- linux-2.4.22/include/asm-i386/pgalloc.h	2003-08-25 13:44:43.000000000 +0200
+++ linux-2.4.22-rtl3.2-pre3/include/asm-i386/pgalloc.h	2003-10-28 13:09:21.000000000 +0100
@@ -158,6 +158,33 @@
 
 extern int do_check_pgt_cache(int, int);
 
+extern inline void set_pgdir(unsigned long address, pgd_t entry)
+{
+	struct task_struct * p;
+	pgd_t *pgd;
+#ifdef CONFIG_SMP
+	int i;
+#endif
+
+	read_lock(&tasklist_lock);
+	for_each_task(p) {
+		if (!p->mm)
+			continue;
+		*pgd_offset(p->mm,address) = entry;
+	}
+	read_unlock(&tasklist_lock);
+#ifndef CONFIG_SMP
+	for (pgd = (pgd_t *)pgd_quicklist; pgd; pgd = (pgd_t *)*(unsigned long *)pgd)
+		pgd[address >> PGDIR_SHIFT] = entry;
+#else
+	/* To pgd_alloc/pgd_free, one holds master kernel lock and so does our callee, so we can
+	   modify pgd caches of other CPUs as well. -jj */
+	for (i = 0; i < NR_CPUS; i++)
+		for (pgd = (pgd_t *)cpu_data[i].pgd_quick; pgd; pgd = (pgd_t *)*(unsigned long *)pgd)
+			pgd[address >> PGDIR_SHIFT] = entry;
+#endif
+}
+
 /*
  * TLB flushing:
  *
diff -rbNu linux-2.4.22/include/asm-i386/rtlinux.h linux-2.4.22-rtl3.2-pre3/include/asm-i386/rtlinux.h
--- linux-2.4.22/include/asm-i386/rtlinux.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.22-rtl3.2-pre3/include/asm-i386/rtlinux.h	2003-10-28 13:03:54.000000000 +0100
@@ -0,0 +1,14 @@
+
+/* RTLinux support for patching the running kernel.
+	* (c) Victor Yodaiken 1999
+*/
+
+#define label_ack_APIC() xlabel_code(0x12344321)
+#define xlabel_code(x) asm __volatile__(".section rtlinux_patch,\"a\"\n .align 4\n"\
+                             ".long 1f,"#x"\n" ".previous\n 1:\n" );
+#define RTLINUX_LABEL(x)\
+  ".section rtlinux_patch,\"a\"\n .align 4\n .long 1f,"#x"\n .previous\n 1:\n"
+
+#define RTLINUX_EXPORT(x)\
+  asm (".section rtlinux_funcs,\"a\"\n .align 4\n"\
+                             ".long "#x"\n .previous\n" );
diff -rbNu linux-2.4.22/include/asm-i386/rtlinux_cli.h linux-2.4.22-rtl3.2-pre3/include/asm-i386/rtlinux_cli.h
--- linux-2.4.22/include/asm-i386/rtlinux_cli.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.22-rtl3.2-pre3/include/asm-i386/rtlinux_cli.h	2003-10-28 13:03:54.000000000 +0100
@@ -0,0 +1,43 @@
+#ifndef RTLINUX_CLI_H
+#define RTLINUX_CLI_H
+
+/* interrupt control.. */
+#define rtl_hard_save_flags_kernel(x)		__asm__ __volatile__("pushfl ; popl %0":"=g" (x): /* no input */ :"memory")
+#define rtl_hard_restore_flags_kernel(x) 	__asm__ __volatile__("pushl %0 ; popfl": /* no output */ :"g" (x):"memory")
+#define rtl_hard_cli_kernel() 		__asm__ __volatile__("cli": : :"memory")
+#define rtl_hard_sti_kernel()			__asm__ __volatile__("sti": : :"memory")
+
+/* For spinlocks etc */
+#define rtl_hard_local_irq_save_kernel(x)	__asm__ __volatile__("pushfl ; popl %0 ; cli":"=g" (x): /* no input */ :"memory")
+#define rtl_hard_local_irq_restore_kernel(x)	__asm__ __volatile__("pushl %0 ; popfl": /* no output */ :"g" (x):"memory")
+#define rtl_hard_local_irq_disable_kernel()	__asm__ __volatile__("cli": : :"memory")
+#define rtl_hard_local_irq_enable_kernel()	__asm__ __volatile__("sti": : :"memory")
+struct irq_control_s {
+	void (*do_save_flags)(unsigned long *);
+	void (*do_restore_flags)(unsigned long);
+	void (*do_cli)(void);
+	void (*do_sti)(void);
+	void (*do_local_irq_save)(unsigned long *);
+	void (*do_local_irq_restore)(unsigned long);
+};
+extern struct irq_control_s irq_control;
+#undef __cli
+#undef __sti
+#undef __save_flags
+#undef __restore_flags
+#undef local_irq_save
+#undef local_irq_restore
+#undef local_irq_disable
+#undef local_irq_enable
+#define __save_flags(x)	irq_control.do_save_flags(&x)
+#define __restore_flags(x) irq_control.do_restore_flags(x)
+#define __cli()		irq_control.do_cli()
+#define __sti()		irq_control.do_sti()
+#define local_irq_save(x)	irq_control.do_local_irq_save((&x))
+#define local_irq_restore(x)	irq_control.do_local_irq_restore(x)
+#define local_irq_disable()	irq_control.do_cli()
+#define local_irq_enable()	irq_control.do_sti()
+
+#undef safe_halt
+#define safe_halt()	do { __asm__ __volatile__("cli; nop; sti; hlt": : :"memory"); irq_control.do_sti();  } while (0)
+#endif /* RTLINUX_CLI_H */
diff -rbNu linux-2.4.22/include/asm-i386/smp.h linux-2.4.22-rtl3.2-pre3/include/asm-i386/smp.h
--- linux-2.4.22/include/asm-i386/smp.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.22-rtl3.2-pre3/include/asm-i386/smp.h	2003-10-28 13:09:21.000000000 +0100
@@ -11,6 +11,7 @@
 #endif
 
 #ifdef CONFIG_X86_LOCAL_APIC
+#include <asm/rtlinux.h>
 #ifndef __ASSEMBLY__
 #include <asm/fixmap.h>
 #include <asm/bitops.h>
@@ -68,6 +69,9 @@
 extern volatile int cpu_to_logical_apicid[NR_CPUS];
 extern volatile int logical_apicid_to_cpu[MAX_APICID];
 
+extern volatile int physical_apicid_2_cpu[];
+#define hw_smp_processor_id() (physical_apicid_2_cpu[hard_smp_processor_id()])
+
 /*
  * General functions that each host system must provide.
  */
@@ -111,5 +115,7 @@
  
 #define PROC_CHANGE_PENALTY	15		/* Schedule penalty */
 
+#else
+#define hw_smp_processor_id() (0)
 #endif
 #endif
diff -rbNu linux-2.4.22/include/asm-i386/system.h linux-2.4.22-rtl3.2-pre3/include/asm-i386/system.h
--- linux-2.4.22/include/asm-i386/system.h	2003-08-25 13:44:43.000000000 +0200
+++ linux-2.4.22-rtl3.2-pre3/include/asm-i386/system.h	2003-10-28 13:09:20.000000000 +0100
@@ -5,6 +5,7 @@
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <asm/segment.h>
+#include <asm/rtlinux.h>
 #include <linux/bitops.h> /* for LOCK_PREFIX */
 
 #ifdef __KERNEL__
@@ -339,6 +340,9 @@
 #define local_irq_disable()	__cli()
 #define local_irq_enable()	__sti()
 
+#ifdef CONFIG_RTLINUX
+#include <asm/rtlinux_cli.h>
+#endif
 #ifdef CONFIG_SMP
 
 extern void __global_cli(void);
diff -rbNu linux-2.4.22/kernel/exit.c linux-2.4.22-rtl3.2-pre3/kernel/exit.c
--- linux-2.4.22/kernel/exit.c	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.22-rtl3.2-pre3/kernel/exit.c	2003-10-28 13:03:54.000000000 +0100
@@ -422,10 +422,14 @@
 	write_unlock_irq(&tasklist_lock);
 }
 
+void (*rtl_do_exit_handler)(long code) = 0;
 NORET_TYPE void do_exit(long code)
 {
 	struct task_struct *tsk = current;
 
+	if (rtl_do_exit_handler) {
+		rtl_do_exit_handler(code);
+	}
 	if (in_interrupt())
 		panic("Aiee, killing interrupt handler!");
 	if (!tsk->pid)
diff -rbNu linux-2.4.22/kernel/fork.c linux-2.4.22-rtl3.2-pre3/kernel/fork.c
--- linux-2.4.22/kernel/fork.c	2003-08-25 13:44:44.000000000 +0200
+++ linux-2.4.22-rtl3.2-pre3/kernel/fork.c	2003-10-28 13:03:54.000000000 +0100
@@ -43,8 +43,8 @@
 {
 	unsigned long flags;
 
+	wq_write_lock_irqsave(&q->lock, flags); //kabi
 	wait->flags &= ~WQ_FLAG_EXCLUSIVE;
-	wq_write_lock_irqsave(&q->lock, flags);
 	__add_wait_queue(q, wait);
 	wq_write_unlock_irqrestore(&q->lock, flags);
 }
@@ -53,8 +53,8 @@
 {
 	unsigned long flags;
 
+	wq_write_lock_irqsave(&q->lock, flags); //kabi
 	wait->flags |= WQ_FLAG_EXCLUSIVE;
-	wq_write_lock_irqsave(&q->lock, flags);
 	__add_wait_queue_tail(q, wait);
 	wq_write_unlock_irqrestore(&q->lock, flags);
 }
@@ -233,7 +233,9 @@
 	atomic_set(&mm->mm_count, 1);
 	init_rwsem(&mm->mmap_sem);
 	mm->page_table_lock = SPIN_LOCK_UNLOCKED;
+	lock_kernel();
 	mm->pgd = pgd_alloc(mm);
+	unlock_kernel();
 	mm->def_flags = 0;
 	if (mm->pgd)
 		return mm;
@@ -265,7 +267,9 @@
 inline void __mmdrop(struct mm_struct *mm)
 {
 	BUG_ON(mm == &init_mm);
+   	lock_kernel();
 	pgd_free(mm->pgd);
+   	unlock_kernel();
 	destroy_context(mm);
 	free_mm(mm);
 }
diff -rbNu linux-2.4.22/mm/vmalloc.c linux-2.4.22-rtl3.2-pre3/mm/vmalloc.c
--- linux-2.4.22/mm/vmalloc.c	2003-08-25 13:44:44.000000000 +0200
+++ linux-2.4.22-rtl3.2-pre3/mm/vmalloc.c	2003-10-28 13:03:54.000000000 +0100
@@ -166,6 +166,7 @@
 	spin_lock(&init_mm.page_table_lock);
 	do {
 		pmd_t *pmd;
+		pgd_t olddir = *dir;
 		
 		pmd = pmd_alloc(&init_mm, dir, address);
 		ret = -ENOMEM;
@@ -175,6 +176,10 @@
 		ret = -ENOMEM;
 		if (alloc_area_pmd(pmd, address, end - address, gfp_mask, prot, pages))
 			break;
+#if defined(__i386__)
+		if (pgd_val(olddir) != pgd_val(*dir))
+			set_pgdir(address, *dir);
+#endif /* __i386__ */
 
 		address = (address + PGDIR_SIZE) & PGDIR_MASK;
 		dir++;
diff -rbNu linux-2.4.22/net/ipv4/netfilter/ipt_MASQUERADE.c~ linux-2.4.22-rtl3.2-pre3/net/ipv4/netfilter/ipt_MASQUERADE.c~
--- linux-2.4.22/net/ipv4/netfilter/ipt_MASQUERADE.c~	2001-09-30 21:26:08.000000000 +0200
+++ linux-2.4.22-rtl3.2-pre3/net/ipv4/netfilter/ipt_MASQUERADE.c~	1970-01-01 01:00:00.000000000 +0100
@@ -1,207 +0,0 @@
-/* Masquerade.  Simple mapping which alters range to a local IP address
-   (depending on route). */
-#include <linux/config.h>
-#include <linux/types.h>
-#include <linux/ip.h>
-#include <linux/timer.h>
-#include <linux/module.h>
-#include <linux/netfilter.h>
-#include <net/protocol.h>
-#include <net/checksum.h>
-#include <linux/netfilter_ipv4.h>
-#include <linux/netfilter_ipv4/ip_nat_rule.h>
-#include <linux/netfilter_ipv4/ip_tables.h>
-
-#if 0
-#define DEBUGP printk
-#else
-#define DEBUGP(format, args...)
-#endif
-
-/* Lock protects masq region inside conntrack */
-static DECLARE_RWLOCK(masq_lock);
-
-/* FIXME: Multiple targets. --RR */
-static int
-masquerade_check(const char *tablename,
-		 const struct ipt_entry *e,
-		 void *targinfo,
-		 unsigned int targinfosize,
-		 unsigned int hook_mask)
-{
-	const struct ip_nat_multi_range *mr = targinfo;
-
-	if (strcmp(tablename, "nat") != 0) {
-		DEBUGP("masquerade_check: bad table `%s'.\n", table);
-		return 0;
-	}
-	if (targinfosize != IPT_ALIGN(sizeof(*mr))) {
-		DEBUGP("masquerade_check: size %u != %u.\n",
-		       targinfosize, sizeof(*mr));
-		return 0;
-	}
-	if (hook_mask & ~(1 << NF_IP_POST_ROUTING)) {
-		DEBUGP("masquerade_check: bad hooks %x.\n", hook_mask);
-		return 0;
-	}
-	if (mr->range[0].flags & IP_NAT_RANGE_MAP_IPS) {
-		DEBUGP("masquerade_check: bad MAP_IPS.\n");
-		return 0;
-	}
-	if (mr->rangesize != 1) {
-		DEBUGP("masquerade_check: bad rangesize %u.\n", mr->rangesize);
-		return 0;
-	}
-	return 1;
-}
-
-static unsigned int
-masquerade_target(struct sk_buff **pskb,
-		  unsigned int hooknum,
-		  const struct net_device *in,
-		  const struct net_device *out,
-		  const void *targinfo,
-		  void *userinfo)
-{
-	struct ip_conntrack *ct;
-	enum ip_conntrack_info ctinfo;
-	const struct ip_nat_multi_range *mr;
-	struct ip_nat_multi_range newrange;
-	u_int32_t newsrc;
-	struct rtable *rt;
-	struct rt_key key;
-
-	IP_NF_ASSERT(hooknum == NF_IP_POST_ROUTING);
-
-	/* FIXME: For the moment, don't do local packets, breaks
-	   testsuite for 2.3.49 --RR */
-	if ((*pskb)->sk)
-		return NF_ACCEPT;
-
-	ct = ip_conntrack_get(*pskb, &ctinfo);
-	IP_NF_ASSERT(ct && (ctinfo == IP_CT_NEW
-				  || ctinfo == IP_CT_RELATED));
-
-	mr = targinfo;
-
-	key.dst = (*pskb)->nh.iph->daddr;
-	key.src = 0; /* Unknown: that's what we're trying to establish */
-	key.tos = RT_TOS((*pskb)->nh.iph->tos)|RTO_CONN;
-	key.oif = out->ifindex;
-#ifdef CONFIG_IP_ROUTE_FWMARK
-	key.fwmark = (*pskb)->nfmark;
-#endif
-	if (ip_route_output_key(&rt, &key) != 0) {
-		/* Shouldn't happen */
-		printk("MASQUERADE: No route: Rusty's brain broke!\n");
-		return NF_DROP;
-	}
-
-	newsrc = rt->rt_src;
-	DEBUGP("newsrc = %u.%u.%u.%u\n", NIPQUAD(newsrc));
-	ip_rt_put(rt);
-
-	WRITE_LOCK(&masq_lock);
-	ct->nat.masq_index = out->ifindex;
-	WRITE_UNLOCK(&masq_lock);
-
-	/* Transfer from original range. */
-	newrange = ((struct ip_nat_multi_range)
-		{ 1, { { mr->range[0].flags | IP_NAT_RANGE_MAP_IPS,
-			 newsrc, newsrc,
-			 mr->range[0].min, mr->range[0].max } } });
-
-	/* Hand modified range to generic setup. */
-	return ip_nat_setup_info(ct, &newrange, hooknum);
-}
-
-static inline int
-device_cmp(const struct ip_conntrack *i, void *ifindex)
-{
-	int ret;
-
-	READ_LOCK(&masq_lock);
-	ret = (i->nat.masq_index == (int)(long)ifindex);
-	READ_UNLOCK(&masq_lock);
-
-	return ret;
-}
-
-static int masq_device_event(struct notifier_block *this,
-			     unsigned long event,
-			     void *ptr)
-{
-	struct net_device *dev = ptr;
-
-	if (event == NETDEV_DOWN) {
-		/* Device was downed.  Search entire table for
-		   conntracks which were associated with that device,
-		   and forget them. */
-		IP_NF_ASSERT(dev->ifindex != 0);
-
-		ip_ct_selective_cleanup(device_cmp, (void *)(long)dev->ifindex);
-	}
-
-	return NOTIFY_DONE;
-}
-
-static int masq_inet_event(struct notifier_block *this,
-			   unsigned long event,
-			   void *ptr)
-{
-	struct net_device *dev = ((struct in_ifaddr *)ptr)->ifa_dev->dev;
-
-	if (event == NETDEV_DOWN) {
-		/* IP address was deleted.  Search entire table for
-		   conntracks which were associated with that device,
-		   and forget them. */
-		IP_NF_ASSERT(dev->ifindex != 0);
-
-		ip_ct_selective_cleanup(device_cmp, (void *)(long)dev->ifindex);
-	}
-
-	return NOTIFY_DONE;
-}
-
-static struct notifier_block masq_dev_notifier = {
-	masq_device_event,
-	NULL,
-	0
-};
-
-static struct notifier_block masq_inet_notifier = {
-	masq_inet_event,
-	NULL,
-	0
-};
-
-static struct ipt_target masquerade
-= { { NULL, NULL }, "MASQUERADE", masquerade_target, masquerade_check, NULL,
-    THIS_MODULE };
-
-static int __init init(void)
-{
-	int ret;
-
-	ret = ipt_register_target(&masquerade);
-
-	if (ret == 0) {
-		/* Register for device down reports */
-		register_netdevice_notifier(&masq_dev_notifier);
-		/* Register IP address change reports */
-		register_inetaddr_notifier(&masq_inet_notifier);
-	}
-
-	return ret;
-}
-
-static void __exit fini(void)
-{
-	ipt_unregister_target(&masquerade);
-	unregister_netdevice_notifier(&masq_dev_notifier);
-	unregister_inetaddr_notifier(&masq_inet_notifier);	
-}
-
-module_init(init);
-module_exit(fini);
-MODULE_LICENSE("GPL");
